"""Vulnerability finding management service."""

from typing import Any, Dict, List, Optional, Union
from uuid import UUID, uuid4

from sqlalchemy.ext.asyncio import AsyncSession
from structlog.stdlib import get_logger

from app.core.errors import NotFoundError, ValidationError
from app.models.vulnerability_finding import VulnerabilityFinding
from app.repositories.vulnerability_finding import VulnerabilityFindingRepository

logger = get_logger(__name__)


class VulnerabilityFindingService:
    """Service for managing vulnerability findings with transaction management."""

    def __init__(self, repository_or_session: Union[VulnerabilityFindingRepository, AsyncSession]):
        """Initialize vulnerability finding service with repository or database session.

        Args:
            repository_or_session: Vulnerability finding repository or AsyncSession
        """
        if isinstance(repository_or_session, AsyncSession):
            self.repository = VulnerabilityFindingRepository(repository_or_session)
        else:
            self.repository = repository_or_session

    async def create_finding(self, finding_data: Dict[str, Any], user_id: str) -> VulnerabilityFinding:
        """Create a new vulnerability finding.

        Args:
            finding_data: Finding creation data
            user_id: User creating the finding

        Returns:
            VulnerabilityFinding: Created finding instance

        Raises:
            ValidationError: If finding data is invalid
        """
        try:
            # Add audit fields
            finding_data.update(
                {
                    "created_by": user_id,
                    "updated_by": user_id,
                }
            )

            finding = await self.repository.create(finding_data)
            logger.info("vulnerability_finding_created", finding_id=finding.id, user_id=user_id)
            return finding

        except Exception as e:
            logger.error("failed_to_create_vulnerability_finding", error=str(e))
            raise ValidationError(f"Failed to create vulnerability finding: {str(e)}")

    async def get_finding(self, finding_id: str) -> Optional[VulnerabilityFinding]:
        """Get vulnerability finding by ID.

        Args:
            finding_id: Finding identifier

        Returns:
            VulnerabilityFinding: Finding instance if found

        Raises:
            NotFoundError: If finding not found
        """
        finding = await self.repository.get(finding_id)
        if not finding:
            raise NotFoundError(f"Vulnerability finding with ID {finding_id} not found")
        return finding

    async def list_findings(
        self,
        skip: int = 0,
        limit: int = 100,
        filters: Optional[Dict[str, Any]] = None,
        severity: Optional[str] = None,
        status: Optional[str] = None,
    ) -> List[VulnerabilityFinding]:
        """List vulnerability findings with pagination and filtering.

        Args:
            skip: Number of findings to skip
            limit: Maximum number of findings to return
            filters: Optional filters to apply
            severity: Optional severity filter
            status: Optional status filter

        Returns:
            List[VulnerabilityFinding]: List of findings
        """
        if not filters:
            filters = {}

        if severity:
            filters["severity"] = severity
        if status:
            filters["status"] = status

        return await self.repository.list(skip=skip, limit=limit, filters=filters)

    async def update_finding(self, finding_id: str, update_data: Dict[str, Any], user_id: str) -> VulnerabilityFinding:
        """Update vulnerability finding.

        Args:
            finding_id: Finding identifier
            update_data: Data to update
            user_id: User performing update

        Returns:
            VulnerabilityFinding: Updated finding instance

        Raises:
            NotFoundError: If finding not found
            ValidationError: If update fails
        """
        try:
            await self.get_finding(finding_id)  # Validate finding exists

            # Add audit fields
            update_data["updated_by"] = user_id

            updated_finding = await self.repository.update(finding_id, update_data)
            logger.info("vulnerability_finding_updated", finding_id=finding_id, user_id=user_id)
            return updated_finding

        except Exception as e:
            logger.error("failed_to_update_vulnerability_finding", finding_id=finding_id, error=str(e))
            raise ValidationError(f"Failed to update vulnerability finding: {str(e)}")

    async def delete_finding(self, finding_id: str, user_id: str) -> bool:
        """Delete vulnerability finding.

        Args:
            finding_id: Finding identifier
            user_id: User performing deletion

        Returns:
            bool: True if deletion successful

        Raises:
            NotFoundError: If finding not found
        """
        try:
            # Verify finding exists before operation

            await self.get_finding(finding_id)
            success = await self.repository.delete(finding_id)
            if success:
                logger.info("vulnerability_finding_deleted", finding_id=finding_id, user_id=user_id)
            return success

        except Exception as e:
            logger.error("failed_to_delete_vulnerability_finding", finding_id=finding_id, error=str(e))
            raise

    async def resolve_finding(self, finding_id: str, user_id: str) -> VulnerabilityFinding:
        """Mark finding as resolved.

        Args:
            finding_id: Finding identifier
            user_id: User resolving the finding

        Returns:
            VulnerabilityFinding: Updated finding instance
        """
        return await self.update_finding(
            finding_id, {"status": "resolved", "resolved_by": user_id, "resolved_at": "now()"}, user_id
        )

    async def reopen_finding(self, finding_id: str, user_id: str) -> VulnerabilityFinding:
        """Reopen a resolved finding.

        Args:
            finding_id: Finding identifier
            user_id: User reopening the finding

        Returns:
            VulnerabilityFinding: Updated finding instance
        """
        return await self.update_finding(
            finding_id, {"status": "open", "resolved_by": None, "resolved_at": None}, user_id
        )

    async def get_findings_by_severity(self, severity: str) -> List[VulnerabilityFinding]:
        """Get all findings by severity level.

        Args:
            severity: Severity level (critical, high, medium, low)

        Returns:
            List[VulnerabilityFinding]: Findings with specified severity
        """
        return await self.list_findings(filters={"severity": severity})

    async def get_finding_statistics(self) -> Dict[str, Any]:
        """Get vulnerability finding statistics.

        Returns:
            Dict: Statistics about vulnerability findings
        """
        # Get all findings for statistics
        all_findings = await self.list_findings(limit=10000)  # Large limit for stats

        stats = {
            "total_findings": len(all_findings),
            "by_severity": {
                "critical": len([f for f in all_findings if getattr(f, "severity", None) == "critical"]),
                "high": len([f for f in all_findings if getattr(f, "severity", None) == "high"]),
                "medium": len([f for f in all_findings if getattr(f, "severity", None) == "medium"]),
                "low": len([f for f in all_findings if getattr(f, "severity", None) == "low"]),
            },
            "by_status": {
                "open": len([f for f in all_findings if getattr(f, "status", None) == "open"]),
                "resolved": len([f for f in all_findings if getattr(f, "status", None) == "resolved"]),
            },
        }

        return stats
