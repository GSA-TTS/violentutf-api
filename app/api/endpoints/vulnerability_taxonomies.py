"""Vulnerability taxonomy CRUD endpoints with comprehensive validation and security."""

from typing import List, Optional

from fastapi import APIRouter, Depends, Query, Request, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.enums import MITREATLASTactic, OWASPLLMCategory, Severity, VulnerabilityCategory
from app.core.errors import NotFoundError, ValidationError
from app.db.session import get_db_dependency
from app.repositories.vulnerability_taxonomy import VulnerabilityTaxonomyRepository
from app.schemas.base import BaseResponse
from app.schemas.vulnerability_taxonomy import (
    DefaultTaxonomiesRequest,
    DefaultTaxonomiesResponse,
    TaxonomyRecommendationRequest,
    TaxonomyRecommendationResponse,
    VulnerabilityTaxonomyCreate,
    VulnerabilityTaxonomyFilter,
    VulnerabilityTaxonomyListResponse,
    VulnerabilityTaxonomyResponse,
    VulnerabilityTaxonomyStatistics,
    VulnerabilityTaxonomyUpdate,
)

router = APIRouter(prefix="/vulnerability-taxonomies", tags=["Vulnerability Taxonomies"])


@router.post("/", response_model=BaseResponse[VulnerabilityTaxonomyResponse], status_code=status.HTTP_201_CREATED)
async def create_taxonomy(
    request: Request,
    taxonomy_data: VulnerabilityTaxonomyCreate,
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[VulnerabilityTaxonomyResponse]:
    """Create a new vulnerability taxonomy."""

    repo = VulnerabilityTaxonomyRepository(db)

    # Convert to dict and add audit fields
    data = taxonomy_data.model_dump()
    data["created_by"] = getattr(request.state, "user_id", "system")
    data["updated_by"] = data["created_by"]

    taxonomy = await repo.create(data)
    await db.commit()

    response_taxonomy = VulnerabilityTaxonomyResponse.model_validate(taxonomy)
    return BaseResponse(
        data=response_taxonomy,
        message="Vulnerability taxonomy created successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/{taxonomy_id}", response_model=BaseResponse[VulnerabilityTaxonomyResponse])
async def get_taxonomy(
    taxonomy_id: str,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[VulnerabilityTaxonomyResponse]:
    """Get a vulnerability taxonomy by ID."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomy = await repo.get_by_id(taxonomy_id, organization_id)

    if not taxonomy:
        raise NotFoundError(message="Vulnerability taxonomy not found")

    response_taxonomy = VulnerabilityTaxonomyResponse.model_validate(taxonomy)
    return BaseResponse(
        data=response_taxonomy,
        message="Vulnerability taxonomy retrieved successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/", response_model=BaseResponse[VulnerabilityTaxonomyListResponse])
async def list_taxonomies(
    request: Request,
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(20, ge=1, le=100, description="Page size"),
    category: Optional[VulnerabilityCategory] = Query(None, description="Filter by category"),
    severity: Optional[Severity] = Query(None, description="Filter by severity"),
    is_ai_specific: Optional[bool] = Query(None, description="Filter by AI-specific taxonomies"),
    owasp_id: Optional[OWASPLLMCategory] = Query(None, description="Filter by OWASP LLM category"),
    atlas_tactic: Optional[MITREATLASTactic] = Query(None, description="Filter by MITRE ATLAS tactic"),
    is_active: Optional[bool] = Query(True, description="Filter by active status"),
    search: Optional[str] = Query(None, min_length=1, max_length=100, description="Search term"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[VulnerabilityTaxonomyListResponse]:
    """List vulnerability taxonomies with filtering and pagination."""

    repo = VulnerabilityTaxonomyRepository(db)

    # Build filters
    filters = {}
    if category:
        filters["category"] = category
    if severity:
        filters["base_severity"] = severity
    if is_ai_specific is not None:
        filters["is_ai_specific"] = is_ai_specific
    if owasp_id:
        filters["owasp_id"] = owasp_id
    if atlas_tactic:
        filters["atlas_tactic"] = atlas_tactic
    if is_active is not None:
        filters["is_active"] = is_active

    # Handle search separately
    if search:
        taxonomies = await repo.search_taxonomies(search, organization_id, limit=size * 5)  # Get more for filtering
        # Apply other filters manually since search is separate
        if filters:
            filtered_taxonomies = []
            for taxonomy in taxonomies:
                match = True
                for field, value in filters.items():
                    if hasattr(taxonomy, field) and getattr(taxonomy, field) != value:
                        match = False
                        break
                if match:
                    filtered_taxonomies.append(taxonomy)
            taxonomies = filtered_taxonomies

        # Manual pagination for search results
        total = len(taxonomies)
        start = (page - 1) * size
        end = start + size
        page_taxonomies = taxonomies[start:end]
        has_next = end < total
        has_prev = page > 1
    else:
        # Use repository pagination
        page_result = await repo.list_with_pagination(
            page=page,
            size=size,
            filters=filters,
            organization_id=organization_id,
            order_by="base_severity",
            order_desc=True,
        )
        page_taxonomies = page_result.items
        total = page_result.total
        has_next = page_result.has_next
        has_prev = page_result.has_prev

    # Convert to response objects
    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in page_taxonomies]

    list_response = VulnerabilityTaxonomyListResponse(
        taxonomies=response_taxonomies, total=total, page=page, size=size, has_next=has_next, has_prev=has_prev
    )

    return BaseResponse(
        data=list_response,
        message=f"Retrieved {len(response_taxonomies)} vulnerability taxonomies",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.put("/{taxonomy_id}", response_model=BaseResponse[VulnerabilityTaxonomyResponse])
async def update_taxonomy(
    taxonomy_id: str,
    taxonomy_update: VulnerabilityTaxonomyUpdate,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[VulnerabilityTaxonomyResponse]:
    """Update a vulnerability taxonomy."""

    repo = VulnerabilityTaxonomyRepository(db)

    # Check if taxonomy exists
    existing_taxonomy = await repo.get_by_id(taxonomy_id, organization_id)
    if not existing_taxonomy:
        raise NotFoundError(message="Vulnerability taxonomy not found")

    # Update with audit fields
    update_data = taxonomy_update.model_dump(exclude_unset=True)
    if update_data:
        update_data["updated_by"] = getattr(request.state, "user_id", "system")

        taxonomy = await repo.update(taxonomy_id, organization_id, **update_data)
        await db.commit()

        if not taxonomy:
            raise NotFoundError(message="Vulnerability taxonomy not found")
    else:
        taxonomy = existing_taxonomy

    response_taxonomy = VulnerabilityTaxonomyResponse.model_validate(taxonomy)
    return BaseResponse(
        data=response_taxonomy,
        message="Vulnerability taxonomy updated successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.delete("/{taxonomy_id}", response_model=BaseResponse[dict])
async def delete_taxonomy(
    taxonomy_id: str,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    hard_delete: bool = Query(False, description="Whether to permanently delete (vs soft delete)"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[dict]:
    """Delete a vulnerability taxonomy (soft delete by default)."""

    repo = VulnerabilityTaxonomyRepository(db)

    success = await repo.delete(taxonomy_id, organization_id, hard_delete=hard_delete)
    if not success:
        raise NotFoundError(message="Vulnerability taxonomy not found")

    await db.commit()

    return BaseResponse(
        data={"deleted": True, "taxonomy_id": taxonomy_id, "hard_delete": hard_delete},
        message=f"Vulnerability taxonomy {'permanently deleted' if hard_delete else 'soft deleted'} successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/statistics/summary", response_model=BaseResponse[VulnerabilityTaxonomyStatistics])
async def get_taxonomy_statistics(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[VulnerabilityTaxonomyStatistics]:
    """Get comprehensive statistics about vulnerability taxonomies."""

    repo = VulnerabilityTaxonomyRepository(db)
    stats = await repo.get_taxonomy_statistics(organization_id)

    statistics = VulnerabilityTaxonomyStatistics(**stats)
    return BaseResponse(
        data=statistics,
        message="Taxonomy statistics retrieved successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/category/{category}", response_model=BaseResponse[List[VulnerabilityTaxonomyResponse]])
async def get_taxonomies_by_category(
    category: VulnerabilityCategory,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[List[VulnerabilityTaxonomyResponse]]:
    """Get all taxonomies for a specific category."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomies = await repo.get_by_category(category, organization_id)

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    return BaseResponse(
        data=response_taxonomies,
        message=f"Retrieved {len(response_taxonomies)} taxonomies for category {category}",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/owasp-llm/all", response_model=BaseResponse[List[VulnerabilityTaxonomyResponse]])
async def get_owasp_llm_taxonomies(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[List[VulnerabilityTaxonomyResponse]]:
    """Get all OWASP LLM Top 10 mapped taxonomies."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomies = await repo.get_owasp_llm_taxonomies(organization_id)

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    return BaseResponse(
        data=response_taxonomies,
        message=f"Retrieved {len(response_taxonomies)} OWASP LLM taxonomies",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/mitre-atlas/all", response_model=BaseResponse[List[VulnerabilityTaxonomyResponse]])
async def get_mitre_atlas_taxonomies(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[List[VulnerabilityTaxonomyResponse]]:
    """Get all MITRE ATLAS mapped taxonomies."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomies = await repo.get_mitre_atlas_taxonomies(organization_id)

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    return BaseResponse(
        data=response_taxonomies,
        message=f"Retrieved {len(response_taxonomies)} MITRE ATLAS taxonomies",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/ai-specific/all", response_model=BaseResponse[List[VulnerabilityTaxonomyResponse]])
async def get_ai_specific_taxonomies(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[List[VulnerabilityTaxonomyResponse]]:
    """Get all AI/ML specific taxonomies."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomies = await repo.get_ai_specific_taxonomies(organization_id)

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    return BaseResponse(
        data=response_taxonomies,
        message=f"Retrieved {len(response_taxonomies)} AI-specific taxonomies",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/severity/{min_severity}", response_model=BaseResponse[List[VulnerabilityTaxonomyResponse]])
async def get_taxonomies_by_severity_range(
    min_severity: Severity,
    request: Request,
    max_severity: Optional[Severity] = Query(None, description="Maximum severity level"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[List[VulnerabilityTaxonomyResponse]]:
    """Get taxonomies within a severity range."""

    repo = VulnerabilityTaxonomyRepository(db)
    taxonomies = await repo.get_by_severity_range(min_severity, max_severity, organization_id)

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    severity_range = f"{min_severity}" + (f" to {max_severity}" if max_severity else " and above")
    return BaseResponse(
        data=response_taxonomies,
        message=f"Retrieved {len(response_taxonomies)} taxonomies for severity {severity_range}",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.post("/defaults/create", response_model=BaseResponse[DefaultTaxonomiesResponse])
async def create_default_taxonomies(
    request_data: DefaultTaxonomiesRequest,
    request: Request,
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[DefaultTaxonomiesResponse]:
    """Create default OWASP LLM Top 10 taxonomies."""

    repo = VulnerabilityTaxonomyRepository(db)

    created_taxonomies = await repo.create_default_taxonomies(request_data.organization_id)
    await db.commit()

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in created_taxonomies]

    # Calculate skipped (existing defaults not created)
    expected_defaults = 3  # Number of default taxonomies we try to create
    created_count = len(created_taxonomies)
    skipped_count = expected_defaults - created_count

    response_data = DefaultTaxonomiesResponse(
        created_count=created_count, skipped_count=skipped_count, created_taxonomies=response_taxonomies
    )

    return BaseResponse(
        data=response_data,
        message=f"Created {created_count} default taxonomies, skipped {skipped_count} existing",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.post("/recommendations", response_model=BaseResponse[TaxonomyRecommendationResponse])
async def get_taxonomy_recommendations(
    recommendation_request: TaxonomyRecommendationRequest,
    request: Request,
    db: AsyncSession = Depends(get_db_dependency),
) -> BaseResponse[TaxonomyRecommendationResponse]:
    """Get recommended taxonomies for a specific target type."""

    repo = VulnerabilityTaxonomyRepository(db)

    taxonomies = await repo.get_recommended_taxonomies(
        recommendation_request.target_type, recommendation_request.organization_id
    )

    response_taxonomies = [VulnerabilityTaxonomyResponse.model_validate(taxonomy) for taxonomy in taxonomies]

    # Generate recommendation reason based on target type
    reason_map = {
        "web_app": "Based on common web application vulnerability patterns including injection, authentication, and authorization flaws",
        "ai_model": "Based on AI/ML specific vulnerability patterns including prompt injection, model manipulation, and adversarial attacks",
        "api": "Based on API security patterns including authentication, authorization, injection, and data exposure risks",
        "llm": "Based on OWASP LLM Top 10 categories including prompt injection, insecure output handling, and training data poisoning",
    }
    reason = reason_map.get(
        recommendation_request.target_type,
        f"Based on vulnerability patterns relevant to {recommendation_request.target_type}",
    )

    response_data = TaxonomyRecommendationResponse(
        target_type=recommendation_request.target_type,
        recommended_taxonomies=response_taxonomies,
        recommendation_reason=reason,
    )

    return BaseResponse(
        data=response_data,
        message=f"Retrieved {len(response_taxonomies)} recommended taxonomies for {recommendation_request.target_type}",
        trace_id=getattr(request.state, "trace_id", None),
    )
