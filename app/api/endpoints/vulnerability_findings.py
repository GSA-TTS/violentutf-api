"""Vulnerability finding CRUD endpoints with comprehensive validation and security."""

from datetime import datetime, timedelta, timezone
from typing import List, Optional

from fastapi import APIRouter, Depends, Query, Request, status
from sqlalchemy.ext.asyncio import AsyncSession
from structlog.stdlib import get_logger

logger = get_logger(__name__)

from app.api.deps import get_db, get_vulnerability_finding_service
from app.core.enums import RiskRating, Severity, VulnerabilityCategory, VulnerabilityStatus
from app.core.errors import NotFoundError, ValidationError

# TECHNICAL DEBT: Direct repository usage violates Clean Architecture
# TODO: Replace with complete service layer methods
from app.repositories.vulnerability_finding import VulnerabilityFindingRepository
from app.schemas.base import BaseResponse
from app.schemas.vulnerability_finding import (
    BulkUpdateRequest,
    BulkUpdateResponse,
    FindingTrendRequest,
    FindingTrendResponse,
    VulnerabilityFindingCreate,
    VulnerabilityFindingFilter,
    VulnerabilityFindingListResponse,
    VulnerabilityFindingResponse,
    VulnerabilityFindingStatistics,
    VulnerabilityFindingUpdate,
)
from app.services.vulnerability_finding_service import VulnerabilityFindingService

router = APIRouter(prefix="/vulnerability-findings", tags=["Vulnerability Findings"])


@router.post("/", response_model=BaseResponse[VulnerabilityFindingResponse], status_code=status.HTTP_201_CREATED)
async def create_finding(
    request: Request,
    finding_data: VulnerabilityFindingCreate,
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[VulnerabilityFindingResponse]:
    """Create a new vulnerability finding."""

    # Use service layer instead of direct repository access
    # Convert to dict and add audit fields
    data = finding_data.model_dump()
    data["created_by"] = getattr(request.state, "user_id", "system")
    data["updated_by"] = data["created_by"]

    # Set discovered_at if not provided
    if not data.get("discovered_at"):
        data["discovered_at"] = datetime.now(timezone.utc)

    finding = await vulnerability_finding_service.create(data)
    # Service layer handles transactions automatically

    response_finding = VulnerabilityFindingResponse.model_validate(finding)
    return BaseResponse(
        data=response_finding,
        message="Vulnerability finding created successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/{finding_id}", response_model=BaseResponse[VulnerabilityFindingResponse])
async def get_finding(
    finding_id: str,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[VulnerabilityFindingResponse]:
    """Get a vulnerability finding by ID."""

    repo = VulnerabilityFindingRepository(db)
    finding = await repo.get_by_id(finding_id, organization_id)

    if not finding:
        raise NotFoundError(message="Vulnerability finding not found")

    response_finding = VulnerabilityFindingResponse.model_validate(finding)
    return BaseResponse(
        data=response_finding,
        message="Vulnerability finding retrieved successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/", response_model=BaseResponse[VulnerabilityFindingListResponse])
async def list_findings(
    request: Request,
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(20, ge=1, le=100, description="Page size"),
    scan_id: Optional[str] = Query(None, description="Filter by scan ID"),
    taxonomy_id: Optional[str] = Query(None, description="Filter by taxonomy ID"),
    severity: Optional[Severity] = Query(None, description="Filter by severity"),
    status: Optional[VulnerabilityStatus] = Query(None, description="Filter by status"),
    risk_rating: Optional[RiskRating] = Query(None, description="Filter by risk rating"),
    assigned_to: Optional[str] = Query(None, description="Filter by assignee"),
    affected_component: Optional[str] = Query(None, description="Filter by affected component"),
    discovery_method: Optional[str] = Query(None, description="Filter by discovery method"),
    ai_model_affected: Optional[str] = Query(None, description="Filter by affected AI model"),
    is_overdue: Optional[bool] = Query(None, description="Filter by overdue status"),
    search: Optional[str] = Query(None, min_length=1, max_length=100, description="Search term"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[VulnerabilityFindingListResponse]:
    """List vulnerability findings with filtering and pagination."""

    repo = VulnerabilityFindingRepository(db)

    # Build filters
    filters = {}
    if scan_id:
        filters["scan_id"] = scan_id
    if taxonomy_id:
        filters["taxonomy_id"] = taxonomy_id
    if severity:
        filters["severity"] = severity
    if status:
        filters["status"] = status
    if risk_rating:
        filters["risk_rating"] = risk_rating
    if assigned_to:
        filters["assigned_to"] = assigned_to
    if affected_component:
        filters["affected_component"] = affected_component
    if discovery_method:
        filters["discovery_method"] = discovery_method
    if ai_model_affected:
        filters["ai_model_affected"] = ai_model_affected

    # Handle search separately
    if search:
        findings = await repo.search_findings(search, organization_id, limit=size * 5)
        # Apply other filters manually since search is separate
        if filters:
            filtered_findings = []
            for finding in findings:
                match = True
                for field, value in filters.items():
                    if hasattr(finding, field) and getattr(finding, field) != value:
                        match = False
                        break
                if match:
                    filtered_findings.append(finding)
            findings = filtered_findings

        # Handle overdue filtering for search results
        if is_overdue is not None:
            now = datetime.now(timezone.utc)
            if is_overdue:
                findings = [
                    f
                    for f in findings
                    if f.remediation_deadline
                    and f.remediation_deadline < now
                    and f.status not in [VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]
                ]
            else:
                findings = [
                    f
                    for f in findings
                    if not f.remediation_deadline
                    or f.remediation_deadline >= now
                    or f.status in [VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]
                ]

        # Manual pagination for search results
        total = len(findings)
        start = (page - 1) * size
        end = start + size
        page_findings = findings[start:end]
        has_next = end < total
        has_prev = page > 1
    else:
        # Use repository pagination
        page_result = await repo.list_with_pagination(
            page=page,
            size=size,
            filters=filters,
            organization_id=organization_id,
            order_by="discovered_at",
            order_desc=True,
        )
        page_findings = page_result.items
        total = page_result.total
        has_next = page_result.has_next
        has_prev = page_result.has_prev

        # Handle overdue filtering for paginated results
        if is_overdue is not None:
            if is_overdue:
                overdue_findings = await repo.get_overdue_findings(organization_id)
                # Filter paginated results to only include overdue ones
                page_findings = [f for f in page_findings if f.id in [of.id for of in overdue_findings]]
            else:
                overdue_findings = await repo.get_overdue_findings(organization_id)
                overdue_ids = [f.id for f in overdue_findings]
                # Filter paginated results to exclude overdue ones
                page_findings = [f for f in page_findings if f.id not in overdue_ids]

    # Convert to response objects with computed fields
    response_findings = []
    now = datetime.now(timezone.utc)
    for finding in page_findings:
        finding_dict = finding.__dict__.copy()

        # Add computed fields
        if finding.discovered_at:
            finding_dict["days_open"] = (now - finding.discovered_at).days

        if finding.remediation_deadline and finding.status not in [
            VulnerabilityStatus.RESOLVED,
            VulnerabilityStatus.FALSE_POSITIVE,
        ]:
            finding_dict["is_overdue"] = finding.remediation_deadline < now
        else:
            finding_dict["is_overdue"] = False

        if finding.resolved_at and finding.discovered_at:
            finding_dict["time_to_remediation"] = (finding.resolved_at - finding.discovered_at).days

        response_findings.append(VulnerabilityFindingResponse.model_validate(finding_dict))

    list_response = VulnerabilityFindingListResponse(
        findings=response_findings, total=total, page=page, size=size, has_next=has_next, has_prev=has_prev
    )

    return BaseResponse(
        data=list_response,
        message=f"Retrieved {len(response_findings)} vulnerability findings",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.put("/{finding_id}", response_model=BaseResponse[VulnerabilityFindingResponse])
async def update_finding(
    finding_id: str,
    finding_update: VulnerabilityFindingUpdate,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[VulnerabilityFindingResponse]:
    """Update a vulnerability finding."""

    repo = VulnerabilityFindingRepository(db)

    # Check if finding exists
    existing_finding = await repo.get_by_id(finding_id, organization_id)
    if not existing_finding:
        raise NotFoundError(message="Vulnerability finding not found")

    # Update with audit fields
    update_data = finding_update.model_dump(exclude_unset=True)
    if update_data:
        update_data["updated_by"] = getattr(request.state, "user_id", "system")

        # Set resolved_at if status changed to resolved
        if "status" in update_data and update_data["status"] == VulnerabilityStatus.RESOLVED:
            update_data["resolved_at"] = datetime.now(timezone.utc)

        finding = await repo.update(finding_id, organization_id, **update_data)
        # Service layer handles transactions automatically

        if not finding:
            raise NotFoundError(message="Vulnerability finding not found")
    else:
        finding = existing_finding

    response_finding = VulnerabilityFindingResponse.model_validate(finding)
    return BaseResponse(
        data=response_finding,
        message="Vulnerability finding updated successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.delete("/{finding_id}", response_model=BaseResponse[dict])
async def delete_finding(
    finding_id: str,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    hard_delete: bool = Query(False, description="Whether to permanently delete (vs soft delete)"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[dict]:
    """Delete a vulnerability finding (soft delete by default)."""

    repo = VulnerabilityFindingRepository(db)

    success = await repo.delete(finding_id, organization_id, hard_delete=hard_delete)
    if not success:
        raise NotFoundError(message="Vulnerability finding not found")

    # Service layer handles transactions automatically

    return BaseResponse(
        data={"deleted": True, "finding_id": finding_id, "hard_delete": hard_delete},
        message=f"Vulnerability finding {'permanently deleted' if hard_delete else 'soft deleted'} successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/statistics/summary", response_model=BaseResponse[VulnerabilityFindingStatistics])
async def get_finding_statistics(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    time_period_days: Optional[int] = Query(None, ge=1, le=365, description="Time period in days"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[VulnerabilityFindingStatistics]:
    """Get comprehensive statistics about vulnerability findings."""

    repo = VulnerabilityFindingRepository(db)
    stats = await repo.get_finding_statistics(organization_id, time_period_days)

    statistics = VulnerabilityFindingStatistics(**stats)
    return BaseResponse(
        data=statistics,
        message="Finding statistics retrieved successfully",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/scan/{scan_id}", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_findings_by_scan(
    scan_id: str,
    request: Request,
    include_resolved: bool = Query(False, description="Include resolved findings"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get all findings for a specific scan."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_by_scan_id(scan_id, organization_id, include_resolved)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} findings for scan {scan_id}",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/severity/{severity}", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_findings_by_severity(
    severity: Severity,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    limit: int = Query(100, ge=1, le=500, description="Maximum number of findings to return"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get findings by severity level."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_by_severity(severity, organization_id, limit)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} {severity} severity findings",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/critical/active", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_critical_active_findings(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get all critical active findings that need immediate attention."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_critical_active_findings(organization_id)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} critical active findings",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/overdue/all", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_overdue_findings(
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get findings past their remediation deadline."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_overdue_findings(organization_id)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} overdue findings",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/component/{component}", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_findings_by_component(
    component: str,
    request: Request,
    active_only: bool = Query(True, description="Only return active findings"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get findings for a specific component."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_findings_by_component(component, organization_id, active_only)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} findings for component {component}",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/assignee/{assignee_id}", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_findings_by_assignee(
    assignee_id: str,
    request: Request,
    active_only: bool = Query(True, description="Only return active findings"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get findings assigned to a specific user."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_findings_by_assignee(assignee_id, organization_id, active_only)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    return BaseResponse(
        data=response_findings,
        message=f"Retrieved {len(response_findings)} findings assigned to {assignee_id}",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.get("/ai-specific/all", response_model=BaseResponse[List[VulnerabilityFindingResponse]])
async def get_ai_specific_findings(
    request: Request,
    model_name: Optional[str] = Query(None, description="Filter by AI model name"),
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[List[VulnerabilityFindingResponse]]:
    """Get AI/ML specific vulnerability findings."""

    repo = VulnerabilityFindingRepository(db)
    findings = await repo.get_ai_specific_findings(model_name, organization_id)

    response_findings = [VulnerabilityFindingResponse.model_validate(finding) for finding in findings]

    message = f"Retrieved {len(response_findings)} AI-specific findings"
    if model_name:
        message += f" for model {model_name}"

    return BaseResponse(
        data=response_findings,
        message=message,
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.put("/bulk/update", response_model=BaseResponse[BulkUpdateResponse])
async def bulk_update_findings(
    bulk_request: BulkUpdateRequest,
    request: Request,
    organization_id: Optional[str] = Query(None, description="Organization ID for multi-tenant filtering"),
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[BulkUpdateResponse]:
    """Bulk update multiple findings."""

    repo = VulnerabilityFindingRepository(db)
    updated_by = getattr(request.state, "user_id", "system")

    # Separate bulk operations based on what's being updated
    updated_count = 0
    failed_count = 0
    errors = []

    try:
        # Status update
        if bulk_request.status:
            count = await repo.bulk_update_status(
                bulk_request.finding_ids, bulk_request.status, updated_by, organization_id
            )
            updated_count += count

        # Assignment update
        if bulk_request.assigned_to:
            count = await repo.bulk_assign_findings(
                bulk_request.finding_ids, bulk_request.assigned_to, updated_by, organization_id
            )
            updated_count = max(updated_count, count)  # Avoid double counting

        # For other fields, update individually
        individual_updates = {}
        if bulk_request.severity:
            individual_updates["severity"] = bulk_request.severity
        if bulk_request.risk_rating:
            individual_updates["risk_rating"] = bulk_request.risk_rating
        if bulk_request.remediation_deadline:
            individual_updates["remediation_deadline"] = bulk_request.remediation_deadline
        if bulk_request.tags:
            individual_updates["tags"] = bulk_request.tags

        if individual_updates:
            individual_updates["updated_by"] = updated_by

            for finding_id in bulk_request.finding_ids:
                try:
                    result = await repo.update(finding_id, organization_id, **individual_updates)
                    if result:
                        updated_count += 1
                    else:
                        failed_count += 1
                        errors.append(f"Finding {finding_id} not found")
                except Exception as e:
                    failed_count += 1
                    # Log the full exception for debugging but don't expose to external users
                    logger.error(f"Failed to update finding {finding_id}", error=str(e))
                    errors.append(f"Failed to update finding {finding_id}")

        # Service layer handles transactions automatically

    except Exception as e:
        failed_count = len(bulk_request.finding_ids)
        # Log the full exception for debugging but don't expose to external users
        logger.error("Bulk update failed", error=str(e))
        errors.append("Bulk update operation failed")

    response_data = BulkUpdateResponse(updated_count=updated_count, failed_count=failed_count, errors=errors)

    return BaseResponse(
        data=response_data,
        message=f"Bulk update completed: {updated_count} updated, {failed_count} failed",
        trace_id=getattr(request.state, "trace_id", None),
    )


@router.post("/trends/data", response_model=BaseResponse[FindingTrendResponse])
async def get_finding_trends(
    trend_request: FindingTrendRequest,
    request: Request,
    vulnerability_finding_service: VulnerabilityFindingService = Depends(get_vulnerability_finding_service),
    db: AsyncSession = Depends(get_db),
) -> BaseResponse[FindingTrendResponse]:
    """Get trend data for findings over time."""

    repo = VulnerabilityFindingRepository(db)
    trend_data = await repo.get_trend_data(trend_request.days, trend_request.organization_id)

    response_data = FindingTrendResponse(
        discovery_trend=trend_data["discovery_trend"],
        resolution_trend=trend_data["resolution_trend"],
        period_days=trend_request.days,
    )

    return BaseResponse(
        data=response_data,
        message=f"Retrieved trend data for {trend_request.days} days",
        trace_id=getattr(request.state, "trace_id", None),
    )
