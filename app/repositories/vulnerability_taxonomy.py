"""Repository for vulnerability taxonomy management."""

from typing import Any, Dict, List, Optional

from sqlalchemy import and_, func, or_, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.enums import (
    AttackVector,
    MITREATLASTactic,
    OWASPLLMCategory,
    Severity,
    VulnerabilityCategory,
)
from app.models.vulnerability_taxonomy import VulnerabilityTaxonomy
from app.repositories.base import BaseRepository


class VulnerabilityTaxonomyRepository(BaseRepository[VulnerabilityTaxonomy]):
    """Repository for vulnerability taxonomy operations."""

    def __init__(self, session: AsyncSession):
        super().__init__(session, VulnerabilityTaxonomy)

    async def get_by_cwe_id(
        self, cwe_id: str, organization_id: Optional[str] = None
    ) -> Optional[VulnerabilityTaxonomy]:
        """Get taxonomy by CWE ID.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.cwe_id == cwe_id,
            self.model.is_active == True,
        ]  # noqa: E712

        result = await self.session.execute(select(self.model).where(and_(*filters)))
        return result.scalar_one_or_none()

    async def get_by_owasp_id(
        self, owasp_id: OWASPLLMCategory, organization_id: Optional[str] = None
    ) -> Optional[VulnerabilityTaxonomy]:
        """Get taxonomy by OWASP LLM ID."""
        # Note: Taxonomies are system-wide standards, organization_id is ignored
        filters = [
            self.model.owasp_id == owasp_id,
            self.model.is_active == True,
        ]  # noqa: E712

        result = await self.session.execute(select(self.model).where(and_(*filters)))
        return result.scalar_one_or_none()

    async def get_by_atlas_technique(
        self, atlas_technique: str, organization_id: Optional[str] = None
    ) -> Optional[VulnerabilityTaxonomy]:
        """Get taxonomy by MITRE ATLAS technique.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.atlas_technique == atlas_technique,
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(select(self.model).where(and_(*filters)))
        return result.scalar_one_or_none()

    async def get_by_category(
        self, category: VulnerabilityCategory, organization_id: Optional[str] = None
    ) -> List[VulnerabilityTaxonomy]:
        """Get all active taxonomies by category.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.category == category,
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.base_severity.desc(), self.model.name)
        )
        return list(result.scalars().all())

    async def get_ai_specific_taxonomies(self, organization_id: Optional[str] = None) -> List[VulnerabilityTaxonomy]:
        """Get all AI-specific taxonomies.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.is_ai_specific == True,
            self.model.is_active == True,
        ]  # noqa: E712  # noqa: E712
        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.category, self.model.base_severity.desc())
        )
        return list(result.scalars().all())

    async def get_owasp_llm_taxonomies(self, organization_id: Optional[str] = None) -> List[VulnerabilityTaxonomy]:
        """Get all OWASP LLM Top 10 taxonomies.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.owasp_id.isnot(None),
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(select(self.model).where(and_(*filters)).order_by(self.model.owasp_id))
        return list(result.scalars().all())

    async def get_mitre_atlas_taxonomies(self, organization_id: Optional[str] = None) -> List[VulnerabilityTaxonomy]:
        """Get all MITRE ATLAS mapped taxonomies.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [
            self.model.atlas_technique.isnot(None),
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.atlas_tactic, self.model.atlas_technique)
        )
        return list(result.scalars().all())

    async def get_by_severity_range(
        self,
        min_severity: Severity,
        max_severity: Optional[Severity] = None,
        organization_id: Optional[str] = None,
    ) -> List[VulnerabilityTaxonomy]:
        """Get taxonomies by severity range.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        severity_order = {
            Severity.INFO: 1,
            Severity.LOW: 2,
            Severity.MEDIUM: 3,
            Severity.HIGH: 4,
            Severity.CRITICAL: 5,
        }

        min_order = severity_order.get(min_severity, 1)
        max_order = severity_order.get(max_severity, 5) if max_severity else 5

        # Map back to severity values
        severity_values = [k for k, v in severity_order.items() if min_order <= v <= max_order]

        filters = [
            self.model.base_severity.in_(severity_values),
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.base_severity.desc(), self.model.name)
        )
        return list(result.scalars().all())

    async def search_taxonomies(
        self, search_term: str, organization_id: Optional[str] = None, limit: int = 50
    ) -> List[VulnerabilityTaxonomy]:
        """Search taxonomies by name, description, or IDs."""
        search_pattern = f"%{search_term}%"

        filters = [
            or_(
                self.model.name.ilike(search_pattern),
                self.model.description.ilike(search_pattern),
                self.model.cwe_id.ilike(search_pattern),
                self.model.cve_id.ilike(search_pattern),
                self.model.atlas_technique.ilike(search_pattern),
            ),
            self.model.is_active == True,  # noqa: E712
        ]
        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.base_severity.desc(), self.model.name)
            .limit(limit)
        )
        return list(result.scalars().all())

    async def get_taxonomy_statistics(self, organization_id: Optional[str] = None) -> Dict[str, Any]:
        """Get statistics about vulnerability taxonomies.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        base_filters = [self.model.is_active == True]  # noqa: E712

        # Total count
        total_result = await self.session.execute(select(func.count(self.model.id)).where(and_(*base_filters)))
        total_count = total_result.scalar_one()

        # Count by category
        category_result = await self.session.execute(
            select(self.model.category, func.count(self.model.id))
            .where(and_(*base_filters))
            .group_by(self.model.category)
        )
        category_counts = {cat.value: count for cat, count in category_result.all()}

        # Count by severity
        severity_result = await self.session.execute(
            select(self.model.base_severity, func.count(self.model.id))
            .where(and_(*base_filters))
            .group_by(self.model.base_severity)
        )
        severity_counts = {sev.value: count for sev, count in severity_result.all()}

        # AI-specific count
        ai_result = await self.session.execute(
            select(func.count(self.model.id)).where(
                and_(*base_filters, self.model.is_ai_specific == True)  # noqa: E712
            )
        )
        ai_count = ai_result.scalar_one()

        # OWASP LLM count
        owasp_result = await self.session.execute(
            select(func.count(self.model.id)).where(and_(*base_filters, self.model.owasp_id.isnot(None)))
        )
        owasp_count = owasp_result.scalar_one()

        # MITRE ATLAS count
        atlas_result = await self.session.execute(
            select(func.count(self.model.id)).where(and_(*base_filters, self.model.atlas_technique.isnot(None)))
        )
        atlas_count = atlas_result.scalar_one()

        return {
            "total_taxonomies": total_count,
            "by_category": category_counts,
            "by_severity": severity_counts,
            "ai_specific": ai_count,
            "owasp_llm_mapped": owasp_count,
            "mitre_atlas_mapped": atlas_count,
            "coverage": {
                "ai_coverage": (ai_count / total_count * 100) if total_count > 0 else 0,
                "owasp_coverage": ((owasp_count / total_count * 100) if total_count > 0 else 0),
                "atlas_coverage": ((atlas_count / total_count * 100) if total_count > 0 else 0),
            },
        }

    async def get_recommended_taxonomies(
        self,
        target_type: str,
        organization_id: Optional[str] = None,  # "web_app", "ai_model", "api", etc.
    ) -> List[VulnerabilityTaxonomy]:
        """Get recommended taxonomies for a specific target type."""
        # Define mappings of target types to relevant categories
        target_category_mapping = {
            "web_app": [
                VulnerabilityCategory.INJECTION,
                VulnerabilityCategory.AUTHENTICATION,
                VulnerabilityCategory.AUTHORIZATION,
                VulnerabilityCategory.DATA_EXPOSURE,
            ],
            "ai_model": [
                VulnerabilityCategory.PROMPT_INJECTION,
                VulnerabilityCategory.MODEL_DOS,
                VulnerabilityCategory.ADVERSARIAL_ML,
                VulnerabilityCategory.MODEL_THEFT,
            ],
            "api": [
                VulnerabilityCategory.AUTHENTICATION,
                VulnerabilityCategory.AUTHORIZATION,
                VulnerabilityCategory.INJECTION,
                VulnerabilityCategory.DATA_EXPOSURE,
            ],
            "llm": [
                VulnerabilityCategory.PROMPT_INJECTION,
                VulnerabilityCategory.INSECURE_OUTPUT,
                VulnerabilityCategory.TRAINING_DATA_POISONING,
                VulnerabilityCategory.OVERRELIANCE,
            ],
        }

        relevant_categories = target_category_mapping.get(target_type, [])
        if not relevant_categories:
            # Default to high-severity taxonomies
            return await self.get_by_severity_range(Severity.HIGH, organization_id=organization_id)

        filters = [
            self.model.category.in_(relevant_categories),
            self.model.is_active == True,
        ]  # noqa: E712
        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.base_severity.desc(), self.model.exploitability_score.desc())
            .limit(20)  # Top 20 recommendations
        )
        return list(result.scalars().all())

    async def bulk_activate_deactivate(
        self,
        taxonomy_ids: List[str],
        is_active: bool,
        organization_id: Optional[str] = None,
    ) -> int:
        """Bulk activate or deactivate taxonomies.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        filters = [self.model.id.in_(taxonomy_ids)]
        result = await self.session.execute(update(self.model).where(and_(*filters)).values(is_active=is_active))
        await self.session.commit()
        return result.rowcount or 0

    async def create_default_taxonomies(self, organization_id: Optional[str] = None) -> List[VulnerabilityTaxonomy]:
        """Create default vulnerability taxonomies for OWASP LLM Top 10.

        Note: Taxonomies are system-wide standards, organization_id parameter is ignored.
        """
        default_taxonomies = [
            {
                "name": "Prompt Injection",
                "category": VulnerabilityCategory.PROMPT_INJECTION,
                "description": "Manipulating AI model via crafted inputs to bypass safety filters or produce unintended outputs",
                "owasp_id": OWASPLLMCategory.LLM01_PROMPT_INJECTION,
                "is_ai_specific": True,
                "attack_vector": AttackVector.PROMPT,
                "base_severity": Severity.CRITICAL,
                "exploitability_score": 8.5,
                "impact_score": 9.0,
                "detection_methods": '["Pattern matching", "Semantic analysis", "Response monitoring"]',
                "remediation_guidance": "Implement input validation, output filtering, and prompt sanitization",
            },
            {
                "name": "Insecure Output Handling",
                "category": VulnerabilityCategory.INSECURE_OUTPUT,
                "description": "Insufficient validation of model outputs leading to injection attacks",
                "owasp_id": OWASPLLMCategory.LLM02_INSECURE_OUTPUT,
                "is_ai_specific": True,
                "attack_vector": AttackVector.NETWORK,
                "base_severity": Severity.HIGH,
                "exploitability_score": 7.0,
                "impact_score": 8.0,
                "detection_methods": '["Output validation", "Content analysis", "XSS scanning"]',
                "remediation_guidance": "Sanitize and validate all model outputs before use",
            },
            {
                "name": "Training Data Poisoning",
                "category": VulnerabilityCategory.TRAINING_DATA_POISONING,
                "description": "Malicious data injection during model training to influence behavior",
                "owasp_id": OWASPLLMCategory.LLM03_TRAINING_POISONING,
                "is_ai_specific": True,
                "attack_vector": AttackVector.NETWORK,
                "base_severity": Severity.HIGH,
                "exploitability_score": 6.0,
                "impact_score": 9.0,
                "detection_methods": '["Data validation", "Anomaly detection", "Provenance tracking"]',
                "remediation_guidance": "Implement data validation, source verification, and training monitoring",
            },
        ]

        created_taxonomies = []
        for taxonomy_data in default_taxonomies:
            # Check if already exists
            existing = await self.get_by_owasp_id(taxonomy_data["owasp_id"], organization_id)
            if not existing:
                taxonomy = await self.create(taxonomy_data)
                created_taxonomies.append(taxonomy)

        return created_taxonomies
