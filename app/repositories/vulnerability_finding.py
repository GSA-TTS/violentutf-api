"""Repository for vulnerability finding management."""

from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Tuple

from sqlalchemy import and_, func, or_, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.enums import (
    RiskRating,
    Severity,
    VulnerabilityCategory,
    VulnerabilityStatus,
)
from app.models.security_scan import SecurityScan
from app.models.vulnerability_finding import VulnerabilityFinding
from app.models.vulnerability_taxonomy import VulnerabilityTaxonomy
from app.repositories.base import BaseRepository


class VulnerabilityFindingRepository(BaseRepository[VulnerabilityFinding]):
    """Repository for vulnerability finding operations."""

    def __init__(self, session: AsyncSession):
        super().__init__(session, VulnerabilityFinding)

    async def get_by_scan_id(
        self,
        scan_id: str,
        organization_id: Optional[str] = None,
        include_resolved: bool = False,
    ) -> List[VulnerabilityFinding]:
        """Get all findings for a specific scan."""
        filters = [
            self.model.scan_id == scan_id,
            self.model.is_active == True,
        ]  # noqa: E712

        if not include_resolved:
            filters.append(self.model.status != VulnerabilityStatus.RESOLVED)

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.discovered_at.desc())
        )
        return list(result.scalars().all())

    async def get_by_severity(
        self,
        severity: Severity,
        organization_id: Optional[str] = None,
        limit: int = 100,
    ) -> List[VulnerabilityFinding]:
        """Get findings by severity level."""
        filters = [
            self.model.severity == severity,
            self.model.status.notin_([VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]),
            self.model.is_active == True,  # noqa: E712
        ]

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.discovered_at.desc()).limit(limit)
        )
        return list(result.scalars().all())

    async def get_critical_active_findings(self, organization_id: Optional[str] = None) -> List[VulnerabilityFinding]:
        """Get all critical active findings that need immediate attention."""
        filters = [
            self.model.severity == Severity.CRITICAL,
            self.model.status.in_(
                [
                    VulnerabilityStatus.NEW,
                    VulnerabilityStatus.CONFIRMED,
                    VulnerabilityStatus.IN_PROGRESS,
                ]
            ),
            self.model.is_active == True,  # noqa: E712
        ]

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model).where(and_(*filters)).order_by(self.model.discovered_at.desc())
        )
        return list(result.scalars().all())

    async def get_findings_by_component(
        self,
        component: str,
        organization_id: Optional[str] = None,
        active_only: bool = True,
    ) -> List[VulnerabilityFinding]:
        """Get findings for a specific component."""
        filters = [self.model.affected_component == component]

        if active_only:
            filters.extend(
                [
                    self.model.status.notin_(
                        [
                            VulnerabilityStatus.RESOLVED,
                            VulnerabilityStatus.FALSE_POSITIVE,
                        ]
                    ),
                    self.model.is_active == True,  # noqa: E712
                ]
            )

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.discovered_at.desc())
        )
        return list(result.scalars().all())

    async def get_overdue_findings(self, organization_id: Optional[str] = None) -> List[VulnerabilityFinding]:
        """Get findings past their remediation deadline."""
        now = datetime.now(timezone.utc)

        filters = [
            self.model.remediation_deadline < now,
            self.model.status.notin_([VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]),
            self.model.is_active == True,  # noqa: E712
        ]

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.remediation_deadline)
        )
        return list(result.scalars().all())

    async def get_findings_by_assignee(
        self,
        assignee_id: str,
        organization_id: Optional[str] = None,
        active_only: bool = True,
    ) -> List[VulnerabilityFinding]:
        """Get findings assigned to a specific user."""
        filters = [self.model.assigned_to == assignee_id]

        if active_only:
            filters.extend(
                [
                    self.model.status.notin_(
                        [
                            VulnerabilityStatus.RESOLVED,
                            VulnerabilityStatus.FALSE_POSITIVE,
                        ]
                    ),
                    self.model.is_active == True,  # noqa: E712
                ]
            )

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.remediation_deadline.asc())
        )
        return list(result.scalars().all())

    async def get_ai_specific_findings(
        self, model_name: Optional[str] = None, organization_id: Optional[str] = None
    ) -> List[VulnerabilityFinding]:
        """Get AI/ML specific vulnerability findings."""
        filters = [
            self.model.ai_model_affected.isnot(None),
            self.model.status.notin_([VulnerabilityStatus.RESOLVED, VulnerabilityStatus.FALSE_POSITIVE]),
            self.model.is_active == True,  # noqa: E712
        ]

        if model_name:
            filters.append(self.model.ai_model_affected.ilike(f"%{model_name}%"))

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.discovered_at.desc())
        )
        return list(result.scalars().all())

    async def search_findings(
        self, search_term: str, organization_id: Optional[str] = None, limit: int = 50
    ) -> List[VulnerabilityFinding]:
        """Search findings by title, description, or component."""
        search_pattern = f"%{search_term}%"

        filters = [
            or_(
                self.model.title.ilike(search_pattern),
                self.model.description.ilike(search_pattern),
                self.model.affected_component.ilike(search_pattern),
                self.model.affected_endpoint.ilike(search_pattern),
                self.model.external_id.ilike(search_pattern),
            ),
            self.model.is_active == True,  # noqa: E712
        ]

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            select(self.model)
            .where(and_(*filters))
            .order_by(self.model.severity.desc(), self.model.discovered_at.desc())
            .limit(limit)
        )
        return list(result.scalars().all())

    async def get_finding_statistics(
        self,
        organization_id: Optional[str] = None,
        time_period_days: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Get comprehensive statistics about vulnerability findings."""
        base_filters = [self.model.is_active == True]  # noqa: E712

        if organization_id:
            base_filters.append(self.model.organization_id == organization_id)

        if time_period_days:
            cutoff_date = datetime.now(timezone.utc) - timedelta(days=time_period_days)
            base_filters.append(self.model.discovered_at >= cutoff_date)

        # Total count by status
        status_result = await self.session.execute(
            select(self.model.status, func.count(self.model.id)).where(and_(*base_filters)).group_by(self.model.status)
        )
        status_counts = {str(status): count for status, count in status_result.all()}

        # Count by severity
        severity_result = await self.session.execute(
            select(self.model.severity, func.count(self.model.id))
            .where(and_(*base_filters))
            .group_by(self.model.severity)
        )
        severity_counts = {str(sev): count for sev, count in severity_result.all()}

        # Count by risk rating
        risk_result = await self.session.execute(
            select(self.model.risk_rating, func.count(self.model.id))
            .where(and_(*base_filters))
            .group_by(self.model.risk_rating)
        )
        risk_counts = {str(risk): count for risk, count in risk_result.all()}

        # Active findings (not resolved or false positive)
        active_result = await self.session.execute(
            select(func.count(self.model.id)).where(
                and_(
                    *base_filters,
                    self.model.status.notin_(
                        [
                            VulnerabilityStatus.RESOLVED,
                            VulnerabilityStatus.FALSE_POSITIVE,
                        ]
                    ),
                )
            )
        )
        active_count = active_result.scalar_one()

        # AI-specific findings
        ai_result = await self.session.execute(
            select(func.count(self.model.id)).where(and_(*base_filters, self.model.ai_model_affected.isnot(None)))
        )
        ai_count = ai_result.scalar_one()

        # Overdue findings
        overdue_result = await self.session.execute(
            select(func.count(self.model.id)).where(
                and_(
                    *base_filters,
                    self.model.remediation_deadline < datetime.now(timezone.utc),
                    self.model.status.notin_(
                        [
                            VulnerabilityStatus.RESOLVED,
                            VulnerabilityStatus.FALSE_POSITIVE,
                        ]
                    ),
                )
            )
        )
        overdue_count = overdue_result.scalar_one()

        # Average resolution time (for resolved findings)
        resolution_time_result = await self.session.execute(
            select(
                func.avg(func.extract("epoch", self.model.resolved_at - self.model.discovered_at)).label(
                    "avg_resolution_seconds"
                )
            ).where(
                and_(
                    *base_filters,
                    self.model.status == VulnerabilityStatus.RESOLVED,
                    self.model.resolved_at.isnot(None),
                )
            )
        )
        avg_resolution_seconds = resolution_time_result.scalar_one() or 0

        # Top affected components
        component_result = await self.session.execute(
            select(
                self.model.affected_component,
                func.count(self.model.id).label("finding_count"),
                func.count(func.nullif(self.model.severity == Severity.CRITICAL, False)).label("critical_count"),
            )
            .where(
                and_(
                    *base_filters,
                    self.model.affected_component.isnot(None),
                    self.model.status.notin_(
                        [
                            VulnerabilityStatus.RESOLVED,
                            VulnerabilityStatus.FALSE_POSITIVE,
                        ]
                    ),
                )
            )
            .group_by(self.model.affected_component)
            .order_by(func.count(self.model.id).desc())
            .limit(10)
        )

        top_components = [
            {
                "component": comp,
                "total_findings": total,
                "critical_findings": critical or 0,
            }
            for comp, total, critical in component_result.all()
        ]

        return {
            "total_findings": sum(status_counts.values()),
            "active_findings": active_count,
            "by_status": status_counts,
            "by_severity": severity_counts,
            "by_risk_rating": risk_counts,
            "ai_specific_count": ai_count,
            "overdue_count": overdue_count,
            "avg_resolution_time_hours": (avg_resolution_seconds / 3600 if avg_resolution_seconds else 0),
            "top_affected_components": top_components,
            "metrics": {
                "resolution_rate": (status_counts.get("resolved", 0) / max(sum(status_counts.values()), 1)) * 100,
                "false_positive_rate": (status_counts.get("false_positive", 0) / max(sum(status_counts.values()), 1))
                * 100,
                "critical_percentage": (severity_counts.get("critical", 0) / max(sum(severity_counts.values()), 1))
                * 100,
                "ai_vulnerability_percentage": (ai_count / max(sum(status_counts.values()), 1)) * 100,
            },
        }

    async def bulk_update_status(
        self,
        finding_ids: List[str],
        status: VulnerabilityStatus,
        updated_by: str = "system",
        organization_id: Optional[str] = None,
    ) -> int:
        """Bulk update status for multiple findings."""
        filters = [self.model.id.in_(finding_ids)]
        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        update_data = {"status": status, "updated_by": updated_by}

        # Set resolved_at for resolved status
        if status == VulnerabilityStatus.RESOLVED:
            update_data["resolved_at"] = datetime.now(timezone.utc)

        result = await self.session.execute(update(self.model).where(and_(*filters)).values(**update_data))

        await self.session.commit()
        return result.rowcount or 0

    async def bulk_assign_findings(
        self,
        finding_ids: List[str],
        assignee_id: str,
        updated_by: str = "system",
        organization_id: Optional[str] = None,
    ) -> int:
        """Bulk assign findings to a user."""
        filters = [self.model.id.in_(finding_ids)]
        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        result = await self.session.execute(
            update(self.model).where(and_(*filters)).values(assigned_to=assignee_id, updated_by=updated_by)
        )

        await self.session.commit()
        return result.rowcount or 0

    async def get_findings_with_taxonomy(
        self,
        category: Optional[VulnerabilityCategory] = None,
        organization_id: Optional[str] = None,
        limit: int = 100,
    ) -> List[Tuple[VulnerabilityFinding, Optional[VulnerabilityTaxonomy]]]:
        """Get findings with their associated taxonomy information."""
        query = (
            select(self.model, VulnerabilityTaxonomy)
            .outerjoin(
                VulnerabilityTaxonomy,
                self.model.taxonomy_id == VulnerabilityTaxonomy.id,
            )
            .where(self.model.is_active == True)  # noqa: E712
        )

        if category:
            query = query.where(VulnerabilityTaxonomy.category == category)

        if organization_id:
            query = query.where(self.model.organization_id == organization_id)

        query = query.order_by(self.model.severity.desc(), self.model.discovered_at.desc()).limit(limit)

        result = await self.session.execute(query)
        return [(finding, taxonomy) for finding, taxonomy in result.all()]

    async def get_trend_data(
        self, days: int = 30, organization_id: Optional[str] = None
    ) -> Dict[str, List[Dict[str, Any]]]:
        """Get trend data for findings over time."""
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=days)

        filters = [
            self.model.discovered_at >= cutoff_date,
            self.model.is_active == True,
        ]  # noqa: E712

        if organization_id:
            filters.append(self.model.organization_id == organization_id)

        # Daily discovery trend
        discovery_result = await self.session.execute(
            select(
                func.date(self.model.discovered_at).label("discovery_date"),
                func.count(self.model.id).label("count"),
                self.model.severity,
            )
            .where(and_(*filters))
            .group_by(func.date(self.model.discovered_at), self.model.severity)
            .order_by(func.date(self.model.discovered_at))
        )

        # Daily resolution trend
        resolution_filters = filters + [self.model.resolved_at >= cutoff_date]
        resolution_result = await self.session.execute(
            select(
                func.date(self.model.resolved_at).label("resolution_date"),
                func.count(self.model.id).label("count"),
                self.model.severity,
            )
            .where(and_(*resolution_filters))
            .group_by(func.date(self.model.resolved_at), self.model.severity)
            .order_by(func.date(self.model.resolved_at))
        )

        # Organize discovery data
        discovery_trend: Dict[str, Dict[str, int]] = {}
        for date, count, severity in discovery_result.all():
            date_str = date.strftime("%Y-%m-%d")
            if date_str not in discovery_trend:
                discovery_trend[date_str] = {}
            discovery_trend[date_str][str(severity)] = count

        # Organize resolution data
        resolution_trend: Dict[str, Dict[str, int]] = {}
        for date, count, severity in resolution_result.all():
            date_str = date.strftime("%Y-%m-%d")
            if date_str not in resolution_trend:
                resolution_trend[date_str] = {}
            resolution_trend[date_str][str(severity)] = count

        return {
            "discovery_trend": [{"date": date, "data": data} for date, data in sorted(discovery_trend.items())],
            "resolution_trend": [{"date": date, "data": data} for date, data in sorted(resolution_trend.items())],
        }
