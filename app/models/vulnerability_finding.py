"""Vulnerability finding model for tracking discovered security issues."""

from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple

from sqlalchemy import JSON, Boolean, DateTime, Float, ForeignKey, Index, String, Text
from sqlalchemy.orm import Mapped, Session, declared_attr, mapped_column, relationship

from app.core.enums import AttackVector, OWASPLLMCategory, RiskRating, Severity, VulnerabilityStatus
from app.db.base_class import Base
from app.models.mixins import AuditMixin, SecurityValidationMixin, SoftDeleteMixin

if TYPE_CHECKING:
    from app.models.security_scan import SecurityScan
    from app.models.user import User
    from app.models.vulnerability_taxonomy import VulnerabilityTaxonomy


class VulnerabilityFinding(Base, AuditMixin, SoftDeleteMixin, SecurityValidationMixin):
    """
    Individual vulnerability finding discovered through scans or manual assessment.

    This model represents a specific instance of a vulnerability found in the system,
    linked to a taxonomy for classification and containing all contextual information
    needed for assessment, verification, and remediation.
    """

    __tablename__ = "vulnerability_findings"

    # Relationships
    taxonomy_id: Mapped[Optional[str]] = mapped_column(
        String, ForeignKey("vulnerability_taxonomies.id"), nullable=True, index=True
    )
    scan_id: Mapped[Optional[str]] = mapped_column(String, ForeignKey("security_scans.id"), nullable=True, index=True)

    # Basic Information
    title: Mapped[str] = mapped_column(String(300), nullable=False, index=True)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Discovery Context
    discovered_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, default=lambda: datetime.now(timezone.utc), index=True
    )
    discovered_by: Mapped[str] = mapped_column(String(100), nullable=False, index=True)  # Tool or analyst name
    discovery_method: Mapped[str] = mapped_column(String(50), nullable=False, index=True)  # manual, pyrit, garak, etc.

    # Location and Context
    affected_component: Mapped[Optional[str]] = mapped_column(String(200), nullable=True, index=True)
    affected_endpoint: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    affected_parameter: Mapped[Optional[str]] = mapped_column(String(200), nullable=True)
    file_path: Mapped[Optional[str]] = mapped_column(String(1000), nullable=True)
    line_number: Mapped[Optional[int]] = mapped_column(nullable=True)

    # Evidence and Proof of Concept
    evidence: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSON, nullable=True)  # Payloads, responses, screenshots
    proof_of_concept: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    reproduction_steps: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Risk Assessment
    severity: Mapped[Severity] = mapped_column(nullable=False, index=True)
    risk_rating: Mapped[RiskRating] = mapped_column(nullable=False, index=True)
    cvss_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    cvss_vector: Mapped[Optional[str]] = mapped_column(String(200), nullable=True)
    exploitability: Mapped[Optional[float]] = mapped_column(Float, nullable=True)  # 0.0-10.0
    impact_rating: Mapped[Optional[float]] = mapped_column(Float, nullable=True)  # 0.0-10.0

    # Business Context
    business_impact: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    affected_users: Mapped[Optional[str]] = mapped_column(String(200), nullable=True)  # "all", "admin", "authenticated"
    data_at_risk: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    compliance_impact: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Status and Workflow
    status: Mapped[VulnerabilityStatus] = mapped_column(nullable=False, default=VulnerabilityStatus.NEW, index=True)
    verification_status: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, index=True)
    remediation_status: Mapped[Optional[str]] = mapped_column(String(50), nullable=True, index=True)
    false_positive_reason: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Assignment and Ownership
    assigned_to: Mapped[Optional[str]] = mapped_column(String, ForeignKey("user.id"), nullable=True, index=True)
    remediation_owner: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)

    # Timeline and SLAs
    first_seen: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    last_seen: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True, index=True)
    verified_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    remediation_deadline: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True, index=True)
    resolved_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    # Remediation Information
    remediation_plan: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    remediation_effort: Mapped[Optional[str]] = mapped_column(String(50), nullable=True)  # low, medium, high
    remediation_notes: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    fix_version: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)

    # AI/ML Specific Fields
    ai_model_affected: Mapped[Optional[str]] = mapped_column(String(200), nullable=True)
    prompt_pattern: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # For prompt injection
    model_output: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # Model response
    attack_scenario: Mapped[Optional[str]] = mapped_column(Text, nullable=True)  # MITRE ATLAS scenario

    # Classification Override
    custom_classification: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    classification_confidence: Mapped[Optional[float]] = mapped_column(Float, nullable=True)  # 0.0-1.0

    # Metadata
    external_id: Mapped[Optional[str]] = mapped_column(String(100), nullable=True, index=True)  # External tool ID
    tags: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)
    notes: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Relationships
    taxonomy: Mapped[Optional["VulnerabilityTaxonomy"]] = relationship(
        "VulnerabilityTaxonomy", back_populates="vulnerability_findings"
    )
    scan: Mapped[Optional["SecurityScan"]] = relationship("SecurityScan", back_populates="vulnerability_findings")
    assigned_user: Mapped[Optional["User"]] = relationship("User", foreign_keys=[assigned_to])

    # Database Indexes for Performance
    @declared_attr
    @classmethod
    def __table_args__(cls) -> Any:
        """Define table-specific indexes in addition to mixin indexes."""
        return (
            Index("idx_finding_status_severity", "status", "severity"),
            Index("idx_finding_discovery_timeline", "discovered_at", "status"),
            Index("idx_finding_component_severity", "affected_component", "severity"),
            Index("idx_finding_assignment", "assigned_to", "status"),
            Index("idx_finding_remediation_deadline", "remediation_deadline", "status"),
            Index("idx_finding_scan_taxonomy", "scan_id", "taxonomy_id"),
            Index("idx_finding_last_seen_active", "last_seen", "status"),
            Index("idx_finding_ai_specific", "ai_model_affected", "severity"),
        )

    def __repr__(self) -> str:
        return f"<VulnerabilityFinding(title='{self.title}', severity='{self.severity}', status='{self.status}')>"

    @property
    def is_overdue(self) -> bool:
        """Check if remediation is overdue."""
        if not self.remediation_deadline:
            return False

        return datetime.now(timezone.utc) > self.remediation_deadline and self.status not in [
            VulnerabilityStatus.RESOLVED,
            VulnerabilityStatus.FALSE_POSITIVE,
        ]

    @property
    def age_in_days(self) -> int:
        """Calculate age of finding in days."""
        return (datetime.now(timezone.utc) - self.discovered_at).days

    @property
    def time_to_remediation(self) -> Optional[int]:
        """Calculate time to remediation in days."""
        if not self.resolved_at:
            return None

        return (self.resolved_at - self.discovered_at).days

    @property
    def risk_score(self) -> float:
        """Calculate composite risk score (0.0-10.0)."""
        base_score = 0.0

        # CVSS score if available
        if self.cvss_score:
            base_score = self.cvss_score
        else:
            # Fallback to severity mapping
            severity_mapping = {
                Severity.CRITICAL: 9.5,
                Severity.HIGH: 7.5,
                Severity.MEDIUM: 5.0,
                Severity.LOW: 2.5,
                Severity.INFO: 0.5,
            }
            base_score = severity_mapping.get(self.severity, 0.0)

        # Adjust for exploitability and impact
        if self.exploitability:
            base_score = base_score * (self.exploitability / 10.0)

        if self.impact_rating:
            base_score = (base_score + self.impact_rating) / 2.0

        # Age factor (older findings are riskier)
        age_multiplier = min(1.5, 1.0 + (self.age_in_days / 365.0) * 0.5)

        return min(10.0, base_score * age_multiplier)

    @property
    def is_ai_related(self) -> bool:
        """Check if this is an AI/ML related vulnerability."""
        return bool(self.ai_model_affected or self.prompt_pattern or (self.taxonomy and self.taxonomy.is_ai_specific))

    def get_evidence_summary(self) -> Dict[str, Any]:
        """Get a summary of evidence for display."""
        if not self.evidence:
            return {}

        summary = {}
        if isinstance(self.evidence, dict):
            # Extract key information
            summary["payload"] = self.evidence.get("payload", "")
            summary["response"] = self.evidence.get("response", "")
            summary["request_url"] = self.evidence.get("request_url", "")
            summary["http_method"] = self.evidence.get("http_method", "")
            summary["status_code"] = self.evidence.get("status_code", "")

        return summary

    def set_evidence(self, evidence_dict: Dict[str, Any]) -> None:
        """Set evidence with validation."""
        # Sanitize evidence to prevent XSS in stored data
        if isinstance(evidence_dict, dict):
            sanitized = {}
            for key, value in evidence_dict.items():
                if isinstance(value, str):
                    # Basic security validation
                    validated_value = self.validate_string_security(key, value)
                    sanitized[key] = validated_value
                else:
                    sanitized[key] = value
            self.evidence = sanitized
            return

        self.evidence = evidence_dict  # type: ignore[unreachable]

    def add_note(self, note: str, author: Optional[str] = None) -> None:
        """Add a timestamped note."""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        author_prefix = f"[{author}] " if author else ""
        new_note = f"{timestamp} - {author_prefix}{note}"

        if self.notes:
            self.notes = f"{self.notes}\n{new_note}"
        else:
            self.notes = new_note

    def update_last_seen(self) -> None:
        """Update last seen timestamp."""
        self.last_seen = datetime.now(timezone.utc)

    @classmethod
    def get_critical_findings(cls, session: Session, limit: int = 10) -> List["VulnerabilityFinding"]:
        """Get most critical unresolved findings."""
        return (
            session.query(cls)
            .filter(
                cls.severity == Severity.CRITICAL,
                cls.status.in_(
                    [VulnerabilityStatus.NEW, VulnerabilityStatus.CONFIRMED, VulnerabilityStatus.IN_PROGRESS]
                ),
            )
            .order_by(cls.discovered_at.desc())
            .limit(limit)
            .all()
        )

    @classmethod
    def get_overdue_findings(cls, session: Session) -> List["VulnerabilityFinding"]:
        """Get findings past remediation deadline."""
        now = datetime.now(timezone.utc)
        return (
            session.query(cls)
            .filter(
                cls.remediation_deadline < now,
                cls.status.in_(
                    [VulnerabilityStatus.NEW, VulnerabilityStatus.CONFIRMED, VulnerabilityStatus.IN_PROGRESS]
                ),
            )
            .order_by(cls.remediation_deadline.asc())
            .all()
        )

    @classmethod
    def get_ai_vulnerabilities(cls, session: Session) -> List["VulnerabilityFinding"]:
        """Get AI/ML specific vulnerabilities."""
        return (
            session.query(cls)
            .filter((cls.ai_model_affected.isnot(None)) | (cls.prompt_pattern.isnot(None)))
            .order_by(cls.severity.desc(), cls.discovered_at.desc())
            .all()
        )
