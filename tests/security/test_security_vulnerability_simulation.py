"""
Security Vulnerability Simulation Tests.

This test suite simulates real-world attack scenarios to verify security controls:
- Multi-tenant data breach attempts
- Privilege escalation scenarios
- JWT manipulation attempts
- API key compromise scenarios
- Organization boundary violations

Tests use live endpoints and real attack patterns for comprehensive security validation.
"""

import asyncio
import base64
import hashlib
import hmac
import json
import uuid
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional
from urllib.parse import quote, unquote

import jwt
import pytest
import pytest_asyncio
from httpx import AsyncClient
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.security import create_access_token
from app.main import app
from app.models.api_key import APIKey
from app.models.user import User


class TestMultiTenantDataBreachSimulation:
    """Simulate multi-tenant data breach attempts and verify prevention."""

    @pytest_asyncio.fixture
    async def async_client(self) -> AsyncClient:
        """Create async HTTP client for attack simulation."""
        async with AsyncClient(app=app, base_url="http://testserver") as client:
            yield client

    @pytest_asyncio.fixture
    async def db_session(self) -> AsyncSession:
        """Create live database session."""
        from app.db.session import get_session

        async with get_session() as session:
            yield session

    @pytest_asyncio.fixture
    async def attacker_user(self, db_session: AsyncSession) -> Dict:
        """Create attacker user in organization A."""
        user_id = str(uuid.uuid4())
        org_id = str(uuid.uuid4())

        user_data = {
            "id": user_id,
            "username": f"attacker_{user_id[:8]}",
            "email": f"attacker_{user_id[:8]}@evil.com",
            "organization_id": org_id,
            "is_active": True,
            "is_verified": True,
            "hashed_password": "hashed_password_placeholder",
        }

        user = User(**user_data)
        db_session.add(user)
        await db_session.commit()

        token_data = {
            "sub": user_id,
            "organization_id": org_id,
            "roles": ["viewer"],  # Low privilege attacker
            "type": "access",
        }
        token = create_access_token(data=token_data)

        return {
            "user": user,
            "user_id": user_id,
            "organization_id": org_id,
            "token": token,
            "headers": {"Authorization": f"Bearer {token}"},
        }

    @pytest_asyncio.fixture
    async def victim_user(self, db_session: AsyncSession) -> Dict:
        """Create victim user in organization B."""
        user_id = str(uuid.uuid4())
        org_id = str(uuid.uuid4())  # Different organization

        user_data = {
            "id": user_id,
            "username": f"victim_{user_id[:8]}",
            "email": f"victim_{user_id[:8]}@corp.com",
            "organization_id": org_id,
            "is_active": True,
            "is_verified": True,
            "hashed_password": "hashed_password_placeholder",
        }

        user = User(**user_data)
        db_session.add(user)
        await db_session.commit()

        token_data = {
            "sub": user_id,
            "organization_id": org_id,
            "roles": ["admin"],  # High privilege victim
            "type": "access",
        }
        token = create_access_token(data=token_data)

        return {
            "user": user,
            "user_id": user_id,
            "organization_id": org_id,
            "token": token,
            "headers": {"Authorization": f"Bearer {token}"},
        }

    @pytest.mark.asyncio
    async def test_direct_user_id_manipulation_attack(
        self, async_client: AsyncClient, attacker_user: Dict, victim_user: Dict
    ):
        """Simulate direct user ID manipulation to access victim's data."""
        victim_id = victim_user["user_id"]

        # Attack 1: Direct user ID access
        response = await async_client.get(f"/api/v1/users/{victim_id}", headers=attacker_user["headers"])

        # Should be blocked by organization isolation
        assert response.status_code in [403, 404]

        # Attack 2: Try to update victim's profile
        update_data = {"username": "compromised_user"}
        response = await async_client.put(
            f"/api/v1/users/{victim_id}", json=update_data, headers=attacker_user["headers"]
        )

        # Should be blocked
        assert response.status_code in [403, 404]

    @pytest.mark.asyncio
    async def test_sql_injection_attack_simulation(self, async_client: AsyncClient, attacker_user: Dict):
        """Simulate SQL injection attacks through API parameters."""
        sql_injection_payloads = [
            # Classic SQL injection
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT id, username, email, hashed_password FROM users --",
            # Blind SQL injection
            "' AND (SELECT COUNT(*) FROM users) > 0 --",
            "'; WAITFOR DELAY '00:00:05' --",
            # Second-order SQL injection
            "admin'; UPDATE users SET is_superuser=true WHERE username='attacker",
            # NoSQL injection (if applicable)
            "'; db.users.drop(); //",
            '{"$gt": ""}',
            # Time-based attacks
            "' OR (SELECT COUNT(*) FROM users WHERE SUBSTRING(username,1,1)='a') > 0 WAITFOR DELAY '00:00:02' --",
        ]

        for payload in sql_injection_payloads:
            # Test in search parameters
            encoded_payload = quote(payload)
            response = await async_client.get(
                f"/api/v1/users?search={encoded_payload}", headers=attacker_user["headers"]
            )

            # Should not cause database errors or expose data
            assert response.status_code in [200, 400, 422]

            if response.status_code == 200:
                response_text = response.text.lower()
                # Verify no SQL error messages leaked
                sql_error_indicators = [
                    "syntax error",
                    "mysql",
                    "postgresql",
                    "sqlite",
                    "oracle",
                    "column",
                    "table",
                    "database",
                    "sql",
                    "query failed",
                ]
                for indicator in sql_error_indicators:
                    assert indicator not in response_text

            # Test in other parameters
            response = await async_client.get(
                f"/api/v1/users?username={encoded_payload}", headers=attacker_user["headers"]
            )

            assert response.status_code in [200, 400, 422]

    @pytest.mark.asyncio
    async def test_path_traversal_attack_simulation(self, async_client: AsyncClient, attacker_user: Dict):
        """Simulate path traversal attacks."""
        path_traversal_payloads = [
            # Classic path traversal
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\system",
            # URL encoded
            "%2e%2e%2f%2e%2e%2f%2e%2e%2f",
            "%252e%252e%252f",
            # Double encoding
            "..%252f..%252f..%252f",
            # Unicode encoding
            "..%u2216..%u2216",
            # Null byte injection
            "../../../etc/passwd%00.txt",
        ]

        for payload in path_traversal_payloads:
            # Try path traversal in various endpoints
            endpoints = [
                f"/api/v1/users/{payload}",
                f"/api/v1/files/{payload}",
                f"/api/v1/reports/{payload}",
            ]

            for endpoint in endpoints:
                response = await async_client.get(endpoint, headers=attacker_user["headers"])

                # Should not expose system files
                assert response.status_code in [400, 404, 422]

                if response.status_code == 200:
                    response_text = response.text.lower()
                    # Check for system file indicators
                    system_indicators = [
                        "root:",
                        "bin/bash",
                        "system32",
                        "config",
                        "passwd",
                        "/etc/",
                        "windows\\system",
                    ]
                    for indicator in system_indicators:
                        assert indicator not in response_text

    @pytest.mark.asyncio
    async def test_organization_id_manipulation_attack(
        self, async_client: AsyncClient, attacker_user: Dict, victim_user: Dict
    ):
        """Simulate organization_id manipulation in requests."""
        victim_org_id = victim_user["organization_id"]

        # Attack 1: Try to add organization_id parameter
        response = await async_client.get(
            f"/api/v1/users?organization_id={victim_org_id}", headers=attacker_user["headers"]
        )

        # Should be ignored or filtered by middleware
        assert response.status_code in [200, 400, 403]

        if response.status_code == 200:
            data = response.json()
            # Should not return victim organization's data
            if isinstance(data, list):
                user_ids = [user.get("id") for user in data]
                assert victim_user["user_id"] not in user_ids
            elif isinstance(data, dict) and "items" in data:
                user_ids = [user.get("id") for user in data["items"]]
                assert victim_user["user_id"] not in user_ids

        # Attack 2: Try to manipulate organization context in headers
        malicious_headers = {
            **attacker_user["headers"],
            "X-Organization-ID": victim_org_id,
            "Organization": victim_org_id,
            "Org-Context": victim_org_id,
        }

        response = await async_client.get("/api/v1/users", headers=malicious_headers)

        # Organization context should come from JWT only
        assert response.status_code in [200, 403]

    @pytest.mark.asyncio
    async def test_privilege_escalation_attack_simulation(self, async_client: AsyncClient, attacker_user: Dict):
        """Simulate privilege escalation attacks."""
        # Attack 1: Try to access admin endpoints
        admin_endpoints = [
            "/api/v1/admin/users",
            "/api/v1/admin/system",
            "/api/v1/admin/audit",
            "/api/v1/admin/organizations",
        ]

        for endpoint in admin_endpoints:
            response = await async_client.get(endpoint, headers=attacker_user["headers"])
            # Should be blocked for non-admin user
            assert response.status_code in [403, 404]

        # Attack 2: Try to modify user roles through API
        role_escalation_data = {
            "roles": ["admin", "superuser"],
            "is_superuser": True,
            "permissions": {"*": True},
        }

        response = await async_client.put(
            f"/api/v1/users/{attacker_user['user_id']}", json=role_escalation_data, headers=attacker_user["headers"]
        )

        # Should be blocked or ignored
        assert response.status_code in [400, 403, 422]

    @pytest.mark.asyncio
    async def test_session_hijacking_simulation(self, async_client: AsyncClient, victim_user: Dict):
        """Simulate session hijacking attempts."""
        victim_token = victim_user["token"]

        # Attack 1: Try to reuse victim's token
        response = await async_client.get("/api/v1/users/me", headers={"Authorization": f"Bearer {victim_token}"})

        # This should work (simulating successful token theft)
        # but subsequent security measures should detect anomalies
        if response.status_code == 200:
            user_data = response.json()
            assert user_data["id"] == victim_user["user_id"]

        # Attack 2: Try to use partial token information
        # Decode JWT to extract information (not validation)
        try:
            token_parts = victim_token.split(".")
            if len(token_parts) == 3:
                # Decode payload (without verification)
                payload_b64 = token_parts[1]
                # Add padding if needed
                payload_b64 += "=" * (4 - len(payload_b64) % 4)
                payload = json.loads(base64.b64decode(payload_b64))

                # Try to create new token with victim's data but different expiration
                malicious_payload = {
                    **payload,
                    "exp": int((datetime.now(timezone.utc) + timedelta(days=1)).timestamp()),
                }

                # This should fail due to signature validation
                malicious_token = jwt.encode(malicious_payload, "wrong_secret", algorithm="HS256")

                response = await async_client.get(
                    "/api/v1/users/me", headers={"Authorization": f"Bearer {malicious_token}"}
                )

                # Should be rejected due to invalid signature
                assert response.status_code == 401

        except Exception:
            # JWT manipulation failed as expected
            pass

    @pytest.mark.asyncio
    async def test_api_key_brute_force_attack(self, async_client: AsyncClient, db_session: AsyncSession):
        """Simulate API key brute force attacks."""
        # Common API key patterns to try
        common_patterns = [
            "vutf_test123456789",
            "vutf_admin000000",
            "vutf_api_key_123",
            "vutf_000000000000",
            "vutf_123456789012",
        ]

        failed_attempts = 0
        for fake_key in common_patterns:
            # Try to use fake API key (if API key auth is implemented)
            response = await async_client.get("/api/v1/users", headers={"X-API-Key": fake_key})

            # Should be rejected
            if response.status_code == 401:
                failed_attempts += 1

        # All fake keys should be rejected
        assert failed_attempts == len(common_patterns)

    @pytest.mark.asyncio
    async def test_mass_assignment_attack(self, async_client: AsyncClient, attacker_user: Dict):
        """Simulate mass assignment attacks."""
        # Try to set protected fields through mass assignment
        mass_assignment_payload = {
            # Regular fields
            "username": "new_username",
            "email": "new@example.com",
            # Protected fields that shouldn't be settable
            "is_superuser": True,
            "is_active": False,
            "organization_id": str(uuid.uuid4()),
            "id": str(uuid.uuid4()),
            "created_at": datetime.now().isoformat(),
            "hashed_password": "malicious_password",
            "roles": ["admin"],
            # System fields
            "_sa_instance_state": {},
            "__class__": "AdminUser",
        }

        response = await async_client.put(
            f"/api/v1/users/{attacker_user['user_id']}", json=mass_assignment_payload, headers=attacker_user["headers"]
        )

        # Should either reject entirely or filter protected fields
        if response.status_code == 200:
            # If successful, verify protected fields weren't changed
            updated_user = response.json()

            # These fields should not have been modified
            assert updated_user.get("is_superuser", False) is not True
            assert updated_user.get("organization_id") == attacker_user["organization_id"]

            # Regular fields might be updated
            assert updated_user.get("username") in ["new_username", attacker_user["user"]["username"]]

    @pytest.mark.asyncio
    async def test_timing_attack_simulation(self, async_client: AsyncClient, attacker_user: Dict, victim_user: Dict):
        """Simulate timing attacks to infer information."""
        import time

        # Test timing differences in user lookup
        valid_user_id = attacker_user["user_id"]  # Exists in attacker's org
        invalid_user_id = victim_user["user_id"]  # Exists but different org
        nonexistent_user_id = str(uuid.uuid4())  # Doesn't exist

        # Measure response times
        times = {}
        for test_case, user_id in [
            ("valid", valid_user_id),
            ("invalid_org", invalid_user_id),
            ("nonexistent", nonexistent_user_id),
        ]:
            start_time = time.time()

            response = await async_client.get(f"/api/v1/users/{user_id}", headers=attacker_user["headers"])

            end_time = time.time()
            times[test_case] = end_time - start_time

            # All should return same error status to prevent information leakage
            assert response.status_code in [403, 404]

        # Response times should be similar to prevent timing attacks
        # Allow for some variance but not orders of magnitude difference
        max_time = max(times.values())
        min_time = min(times.values())

        # Timing should not reveal whether user exists in different organization
        # Allow up to 5x difference (generous for CI environments)
        assert max_time / min_time < 5.0

    @pytest.mark.asyncio
    async def test_information_disclosure_prevention(self, async_client: AsyncClient, attacker_user: Dict):
        """Test prevention of information disclosure through error messages."""
        # Test various error conditions
        test_cases = [
            # Nonexistent resources
            ("/api/v1/users/nonexistent-id", [404]),
            ("/api/v1/api-keys/fake-key-id", [403, 404]),
            # Invalid UUIDs
            ("/api/v1/users/invalid-uuid", [400, 404, 422]),
            # Unauthorized access
            ("/api/v1/admin/users", [403, 404]),
        ]

        for endpoint, expected_codes in test_cases:
            response = await async_client.get(endpoint, headers=attacker_user["headers"])

            assert response.status_code in expected_codes

            # Check error message doesn't leak sensitive information
            if response.status_code in [400, 403, 404]:
                error_data = response.json()
                error_message = error_data.get("detail", "").lower()

                # Should not contain sensitive information
                sensitive_keywords = [
                    "organization_id",
                    "database",
                    "sql",
                    "internal",
                    "server error",
                    "stack trace",
                    "exception",
                ]

                for keyword in sensitive_keywords:
                    assert keyword not in error_message

    @pytest.mark.asyncio
    async def test_concurrent_attack_simulation(
        self, async_client: AsyncClient, attacker_user: Dict, victim_user: Dict
    ):
        """Simulate concurrent attacks to test system stability."""

        # Launch concurrent attack requests
        async def attack_request():
            return await async_client.get(f"/api/v1/users/{victim_user['user_id']}", headers=attacker_user["headers"])

        # Execute 20 concurrent attack attempts
        attack_tasks = [attack_request() for _ in range(20)]
        responses = await asyncio.gather(*attack_tasks, return_exceptions=True)

        # All attacks should be blocked consistently
        status_codes = []
        for response in responses:
            if hasattr(response, "status_code"):
                status_codes.append(response.status_code)

        # All should be blocked with same status code
        assert all(code in [403, 404] for code in status_codes)

        # System should remain stable (no 500 errors from overload)
        assert all(code != 500 for code in status_codes)

    async def cleanup_test_users(self, db_session: AsyncSession, attacker_user: Dict, victim_user: Dict):
        """Clean up test users after attack simulation."""
        try:
            if attacker_user.get("user"):
                await db_session.delete(attacker_user["user"])
            if victim_user.get("user"):
                await db_session.delete(victim_user["user"])

            await db_session.commit()
        except Exception as e:
            print(f"Cleanup error (non-fatal): {e}")
            await db_session.rollback()


class TestJWTSecurityValidation:
    """Test JWT token security validation and manipulation detection."""

    @pytest_asyncio.fixture
    async def async_client(self) -> AsyncClient:
        """Create async HTTP client."""
        async with AsyncClient(app=app, base_url="http://testserver") as client:
            yield client

    @pytest.mark.asyncio
    async def test_jwt_algorithm_confusion_attack(self, async_client: AsyncClient):
        """Test protection against JWT algorithm confusion attacks."""
        # Try to use 'none' algorithm
        payload = {
            "sub": str(uuid.uuid4()),
            "organization_id": str(uuid.uuid4()),
            "roles": ["admin"],
            "type": "access",
            "exp": int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()),
        }

        # Create JWT with 'none' algorithm
        none_token = jwt.encode(payload, "", algorithm="none")

        response = await async_client.get("/api/v1/users", headers={"Authorization": f"Bearer {none_token}"})

        # Should be rejected
        assert response.status_code == 401

    @pytest.mark.asyncio
    async def test_jwt_signature_stripping_attack(self, async_client: AsyncClient):
        """Test protection against JWT signature stripping."""
        # Create valid token then remove signature
        payload = {
            "sub": str(uuid.uuid4()),
            "organization_id": str(uuid.uuid4()),
            "roles": ["admin"],
            "type": "access",
            "exp": int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()),
        }

        valid_token = create_access_token(data=payload)

        # Strip signature (remove last part)
        token_parts = valid_token.split(".")
        unsigned_token = ".".join(token_parts[:-1])

        response = await async_client.get("/api/v1/users", headers={"Authorization": f"Bearer {unsigned_token}"})

        # Should be rejected
        assert response.status_code == 401

    @pytest.mark.asyncio
    async def test_jwt_key_confusion_attack(self, async_client: AsyncClient):
        """Test protection against key confusion attacks."""
        # Try to create token with wrong key
        payload = {
            "sub": str(uuid.uuid4()),
            "organization_id": str(uuid.uuid4()),
            "roles": ["admin"],
            "type": "access",
            "exp": int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()),
        }

        # Use wrong signing key
        wrong_key_token = jwt.encode(payload, "wrong_secret_key", algorithm="HS256")

        response = await async_client.get("/api/v1/users", headers={"Authorization": f"Bearer {wrong_key_token}"})

        # Should be rejected
        assert response.status_code == 401

    @pytest.mark.asyncio
    async def test_jwt_claim_manipulation(self, async_client: AsyncClient):
        """Test detection of JWT claim manipulation."""
        # Create valid token
        original_payload = {
            "sub": str(uuid.uuid4()),
            "organization_id": str(uuid.uuid4()),
            "roles": ["viewer"],
            "type": "access",
            "exp": int((datetime.now(timezone.utc) + timedelta(hours=1)).timestamp()),
        }

        valid_token = create_access_token(data=original_payload)

        # Try to manually modify claims (this should fail due to signature)
        token_parts = valid_token.split(".")
        header_b64, payload_b64, signature = token_parts

        # Decode payload
        payload_b64 += "=" * (4 - len(payload_b64) % 4)
        payload = json.loads(base64.b64decode(payload_b64))

        # Modify claims
        payload["roles"] = ["admin", "superuser"]
        payload["organization_id"] = "different_org"

        # Re-encode payload
        modified_payload_b64 = base64.b64encode(json.dumps(payload).encode()).decode().rstrip("=")

        # Create token with modified payload but original signature
        modified_token = f"{header_b64}.{modified_payload_b64}.{signature}"

        response = await async_client.get("/api/v1/users", headers={"Authorization": f"Bearer {modified_token}"})

        # Should be rejected due to signature mismatch
        assert response.status_code == 401
